<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/me.jpg"/>
	<link rel="shortcut icon" href="/img/me.jpg">
	<script data-ad-client="ca-pub-3134773914228719" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	
			    <title>
    Jack's Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="java, computer science, programming" />
    <meta data-react-helmet="true" property="og:image" content="https://www.jacktsaitech.com/images/Cover Page.png">
    <meta data-react-helmet="true" property="og:type" content="website">
    <meta data-react-helmet="true" property="og:url" content="https://www.jacktsaitech.com">
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/highlight.js"></script>
	
<meta name="generator" content="Hexo 6.0.0"><link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_okaidia.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <!-- <header id="header">
    <a href="/" class="logo">JACK</a>
</header> -->
        <header id="post-header"></header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">Home</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            	<a href="#s1">Category</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/LeetCode/">LeetCode</a></li><li><a class="category-link" href="/categories/Operating-System/">Operating System</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/tag/" title="Tag">
		                Tag
		            </a>
		        </li>
		        
		        <li>
		            <a href="/about/" title="About">
		                About
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
					<li class="translate-style">
						<a id="translateButtonObject" href="javascript:translatePage();">繁&#8644;简</a>
					</li>
                    
                    <li>
                        <a title="github" href="https://github.com/jack870131" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="linkedin" href="https://www.linkedin.com/in/tsung-han-jack-tsai-62696314b" target="_blank" rel="noopener">
                            <i class="icon fa fa-linkedin"></i>
                        </a>
                    </li>
                    
			</ul>
			<script type="text/javascript" src="/js/tw_cn.js"></script>
			<script type="text/javascript">
				var defaultEncoding = 2; //網站編寫字體是否繁體，1-繁體，2-簡體
				var translateDelay = 0; //延遲時間,若不在前, 要設定延遲翻譯時間, 如100表示100ms,默認為0
				var cookieDomain = "https://jack870131.github.io/"; //Cookie地址, 一定要設定, 通常為你的網址
				var translateButtonId = "translateLink"; //默認互換id
				translateInitilization();
			</script>
</nav>

        <div id="main" >
            <div class ="post_page_title_img"></div>
            <!-- Post -->
            <div class="typo">
                <h1><span id="java併發機制的底層實現原理">Java併發機制的底層實現原理</span></h1><p>本篇博客主要是紀錄對&lt;&lt;Java并发编程的艺术&gt;&gt;的學習心得以及一些知識點的重新整理，因此文章中會有許多引用自該書的文字。同時也借鑑其他相關的技術博客，以完善整個知識框架。</p>
<h2><span id="volatile的應用">volatile的應用</span></h2><p>volatile與synchronized都是Java併發編程中的重要角色，volatile可以說是輕量級的synchronized，在多處理器開發中保證了共享變量的可見性(當一個線程修改一個共享變量時，另外一個線程能讀到這個修改的值)。volatile的執行成本也是較低的，它不會引起線程上下文的切換和調度。</p>
<h3><span id="volatile的定義與實現原理">volatile的定義與實現原理</span></h3><blockquote>
<p>Java編程語言允許線程訪問共享變量，為了確保共享變量能被準確和一致地更新，線程應該確保通過排他鎖單獨獲得這個變量。Java語言提共了volatile，在某些情況下比鎖更加方便。如果一個字段被聲明成volatile，Java線程內存模型確保所有線程看到這個變量的值是一致的。</p>
</blockquote>
<h3><span id="volatile怎麼保證可見性">volatile怎麼保證可見性</span></h3><p>有volatile變量修飾的共享變量進行寫操作的時候會多出一行擁有Lock前綴的匯編代碼，此指令在多核處理器下匯引發兩件事情:</p>
<ol>
<li>將當前處理器緩存行的數據寫回到系統內存。</li>
<li>這個写回內存的操作會使在其他CPU里緩存了該內存地址的數據無效。</li>
</ol>
<p>如果對聲明了volatile的變量進行寫操作，JVM就會像處理器發送一條Lock前綴的指令，將這個變量所在緩存行的數據寫回到系統內存。但是，就算寫回到內存，如果其他處理器緩存的值還是舊的，再執行計算操作就會有問題。所以，再多處理器下，為了保證個個處理器的緩存是一致的，就會實現緩存一致性協議，每個處理器通過嗅探再總線上傳播的數據來檢查自己緩存的值是不是過期了，當處理器發現自己緩存行對應的內存地址被修改，就會將當前處理器的緩存行設置成無效狀態，當處理器對這個數據進行修改操作的時候，會重新從系統內存中把數據獨到處理器緩存里。</p>
<h3><span id="volatile的實現原則">volatile的實現原則</span></h3><ol>
<li>Lock前綴指令會引起處理器緩存回寫到內存: Lock前綴指令導致在執行指令期間，聲言處理器中的Lock#信號。在目前的處理器中，如果訪問的內存區域已經緩存在處理器內部，則不會聲言Lock#信號。相反，他會鎖定這塊內存區域的緩存並回寫到內存，並使用緩存一致性機制來確保修改的園子性，此操作被稱為”緩存鎖定”，緩存一致性機制會阻止同時修改由兩個以上處理器緩存的內存區域數據。</li>
<li>一個處理器的緩存回寫到內存會導致其他處理器的緩存無效: 處理器使用嗅探技術保證他的內部緩存、系統內存和其他處理器的緩存數據在總線上保持一致。例如，在處理器中，如果通過嗅探一個處理器來檢測其他處理器打算寫內存地址，而這個地址當前處於共享狀態，那麼正在嗅探的處理器將使它的緩存行無效，在下次訪問相同內存地址時，強制執行緩存行填充。</li>
</ol>
<h2><span id="synchronized的實現原理與應用">synchronized的實現原理與應用</span></h2><p>很多人會稱呼synchronized為重量級鎖，但是在Java SE 1.6之後進行了各種優化，減低許多鎖開銷。接下來會介紹Java SE 1.6中為了減少性能消耗而引入的偏向鎖與輕量級鎖，以及鎖的存處結構和升級過程。</p>
<h3><span id="synchronized實現同步的基礎">synchronized實現同步的基礎</span></h3><p>Java中的每一個對象都可以作為鎖。具體表現為以下3種形式:</p>
<ol>
<li>對於普通同步方法，鎖定當前實例對象。</li>
<li>對於靜態同步方法，鎖定當前類的Class對象。</li>
<li>對於同步方法塊，鎖定synchronized括號里配置的對象。</li>
</ol>
<p>JVM規範中可以看到synchronized在JVM裡的實現原理，JVM基於進入和退出Monitor對象來實現方法同步和代碼塊同步，但兩者的實現細節不一樣。代碼塊同步釋使用monitorenter和monitorexit指令實現的，而方法同步釋使用另一種方式實現的。但是，方法的同步同樣可以使用這兩個指令來實現。</p>
<p>monitorenter指令是在編譯後插入到同步代碼塊的開始位置，而monitorexit是插入到方法結束處和異常處，JVM要保證每個monitorenter必須有對應的monitorexit與之配對。任何對象都有一個monitor與之關聯，且當有一個monitor被持有後，它將處於鎖定狀態。線程執行到monitorenter指令時，將會嘗試獲取對象所對應的monitor的所有權，即嘗試獲得對象的鎖。</p>
<h3><span id="java對象頭">Java對象頭</span></h3><p>synchronized用的鎖是存在Java對象頭裡的。如果對象是數組類型，則虛擬機用3個字寬(1 Word = 4 byte = 32 bit)存處對象頭，如果是非數組類型，則用2字寬存儲對象頭。</p>
<table>
<thead>
<tr>
<th align="center">長度</th>
<th align="center">內容</th>
<th align="center">說明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">32/64bit</td>
<td align="center">Mark Word</td>
<td align="center">存儲對象的hashCode或鎖信息等</td>
</tr>
<tr>
<td align="center">32/64bit</td>
<td align="center">Class Metadata Address</td>
<td align="center">存儲到對向類型數據的指針</td>
</tr>
<tr>
<td align="center">32/32bit</td>
<td align="center">Array length</td>
<td align="center">數組的長度(如果當前對象是數組)</td>
</tr>
</tbody></table>
<h3><span id="偏向鎖">偏向鎖</span></h3><p>經過研究發現，大多數情況下，鎖不僅不存在多線程競爭，而且總是由同一線程多次獲得，為了讓線程獲得鎖的代價更低而引入了偏向鎖。當一個線程訪問同步塊並獲取鎖時，會在對向頭和栈幀中的鎖紀錄裡存儲偏向鎖的線程ID，以後該線程在進入和退出同步塊石不需要進行CAS操作來加鎖和解鎖，只需要簡單地測試儀下對象頭的Mark Word裡是否存儲著指向當前線程的偏向鎖。如果測試成功，表示線程已經獲得了鎖。如果測試失敗，則需要再測試一下Mark Word中偏向鎖的標識是否設置成1(表示當前是偏向鎖): 如果沒有設置，則使用CAS競爭鎖; 如果設置了，則嘗試使用CAS將對象頭的偏向鎖指向當前線程。</p>
<h3><span id="輕量級鎖">輕量級鎖</span></h3><ul>
<li>輕量級加鎖: 線程再執行同步塊之前，JVM會先再當前線程的栈幀中創建用於存儲鎖紀錄的空間，並將對象頭中的Mark Word複製到鎖紀錄中，官方稱為Displaced Mark Word。然後線程嘗試使用CAS將對象頭中的Mark Word替換為指向鎖紀錄的指針。如果成功，當前線程獲得鎖，如果失敗，表示其他線程競爭鎖，當前線程便嘗試使用自旋來獲取鎖。</li>
<li>輕量級解鎖: 輕量級解鎖時，會使用園子的CAS操作將Displaced Mark Word替換回到對向頭，如果成功，則表示沒有競爭發生。如果失敗，表示當前鎖存在競爭，鎖就會膨脹成重量級鎖。</li>
</ul>
<h2><span id="鎖的優缺點對比">鎖的優缺點對比</span></h2><p><img src="https://i.imgur.com/cgw4oUe.jpg" alt="各類鎖的優缺點"></p>

            </div>
        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li><br>
                Tsung Han Tsai © 2018 - 2021 • All rights reserved
            </ul>
        </div>
    </div>
</body>

 	
</html>
