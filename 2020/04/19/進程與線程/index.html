<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
	<link rel="bookmark" type="image/x-icon" href="/img/me.jpg">
	<link rel="shortcut icon" href="/img/me.jpg">
	<script data-ad-client="ca-pub-3134773914228719" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	
			    <title>
    Jack's Blog
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    <meta name="keywords" content="java, computer science, programming">
    <meta data-react-helmet="true" property="og:image" content="https://www.jacktsaitech.com/images/Cover Page.png">
    <meta data-react-helmet="true" property="og:type" content="website">
    <meta data-react-helmet="true" property="og:url" content="https://www.jacktsaitech.com">
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/highlight.js"></script>
	
<link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_okaidia.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <!-- <header id="header">
    <a href="/" class="logo">JACK</a>
</header> -->
        <header id="post-header"></header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">Home</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            	<a href="#s1">Category</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Algorithms/">Algorithms</a></li><li><a class="category-link" href="/categories/Concurrency/">Concurrency</a></li><li><a class="category-link" href="/categories/IoTDB/">IoTDB</a></li><li><a class="category-link" href="/categories/LeetCode/">LeetCode</a></li><li><a class="category-link" href="/categories/Operating-System/">Operating System</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/tag/" title="Tag">
		                Tag
		            </a>
		        </li>
		        
		        <li>
		            <a href="/about/" title="About">
		                About
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
					<li class="translate-style">
						<a id="translateButtonObject" href="javascript:translatePage();">繁&#8644;简</a>
					</li>
                    
                    <li>
                        <a title="github" href="https://github.com/jack870131" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="linkedin" href="https://www.linkedin.com/in/tsung-han-jack-tsai-62696314b" target="_blank" rel="noopener">
                            <i class="icon fa fa-linkedin"></i>
                        </a>
                    </li>
                    
			</ul>
			<script type="text/javascript" src="/js/tw_cn.js"></script>
			<script type="text/javascript">
				var defaultEncoding = 2; //網站編寫字體是否繁體，1-繁體，2-簡體
				var translateDelay = 0; //延遲時間,若不在前, 要設定延遲翻譯時間, 如100表示100ms,默認為0
				var cookieDomain = "https://jack870131.github.io/"; //Cookie地址, 一定要設定, 通常為你的網址
				var translateButtonId = "translateLink"; //默認互換id
				translateInitilization();
			</script>
</nav>

        <div id="main">
            <div class="post_page_title_img"></div>
            <!-- Post -->
            <div class="typo">
                <h1><span id="進程與線程">進程與線程</span></h1><h2><span id="進程">進程</span></h2><p>操作系統中最核心的概念是進程，是對正在運行程序的一個抽象。一個進程就是一個正在被執行程序的實例，包括程序計數器、寄存器和變量的當前值。</p>
<h3><span id="系統調用">系統調用</span></h3><p>根據進程訪問資源的特點，可以把進程在系統上的運行分為兩個級別:</p>
<ul>
<li><strong>用戶態 (user mode)</strong>: 用戶態運行的進程可以直接讀取用戶程序的數據。</li>
<li><strong>系統態 (kernel mode)</strong>: 系統態運行的進程或程序幾乎可以訪問計算機的任何資源，不受限制。</li>
</ul>
<h3><span id="進程-vs-程序">進程 v.s. 程序</span></h3><p>如果將操作系統內部視為一個廚房，則程序 (適當形式描述的算法) 相當于食譜，輸入的數據相當于食材，CPU 處理器等同于廚師。進程則是指某種類型的活動，比如廚師閱讀食譜，取食材以及烘焙等動作的總和。</p>
<h3><span id="進程上下文切換">進程上下文切換</span></h3><p>若幹進程可以共享單個 CPU，單個 CPU 一次只能運行一個進程。處裏器在各個進程之間來回快速切換，在任何一個給定的瞬間僅有一個進程真正在運行。由于 CPU 在各個進程之間來回快速切換，所以每個進程執行及運算的速度是不確定的，當同一進程再次運行時，其運算速度通常不可再現。進程切換的基本順序如下:</p>
<ol>
<li>保存當前進程狀態</li>
<li>切換到高優先級進程 (每個進程包含各自程序)</li>
<li>切換到原本進程 (從原本進度開始執行)</li>
</ol>
<h3><span id="進程的層次結構">進程的層次結構</span></h3><p>當進程創建了另一進程後，父進程和子進程就以某種形式繼續保持關聯。進程只可以有一個父進程，但是可以有零個、一個、兩個或多個子進程。舉例 UNIX 在啓動時如何初始化自己來說明進程層次的作用:</p>
<blockquote>
<p>一個稱為 init 的特殊進程出現在啓動映像中。當他開始運行時，讀入一個說明終端數量的文件。接這，未每個終端創建一個新進程。這些進繩等待用戶登錄。如果有一個用戶登錄成功，該登陸進程就執行一個 shell 準備接收命令。所接收的這些命令會啓動更多的進程，以此累堆，在整個系統中，所以的進程都屬于以 init 為根的一棵樹。</p>
</blockquote>
<h3><span id="進程的狀態">進程的狀態</span></h3><p><img src="https://i.imgur.com/hUQ5x3Z.jpg" alt="Process State"></p>
<ul>
<li><p><strong>創建態 (new)</strong>: 進程正在被創建，未達到就緒態。四種事件會導致進程創建:</p>
<ol>
<li><p>系統初始化</p>
</li>
<li><p>正在運行的程序執行創建進程的系統調用</p>
</li>
<li><p>用戶請求創建一個新進程</p>
</li>
<li><p>一個批處理作業的初始化</p>
</li>
</ol>
</li>
<li><p><strong>就緒態 (ready)</strong>: 可運行，但因位其他進程正在運行而戰時終止，一旦得到處裏器資源 (處裏器的時間片) 即可運行。</p>
</li>
<li><p><strong>運行態 (running)</strong>: 進程實際占用 CPU (單核 CPU 任意時刻只有一個進程處于該狀態)。</p>
</li>
<li><p><strong>阻塞態 (waiting)</strong>: 又稱為等待狀態，除非某外部事件 (資源可用或 IO 操作完成) 發生，否則即使處裏器空閑，進程也不能運行。</p>
</li>
<li><p><strong>結束態 (terminated)</strong>: 進程正在從系統上消失，可能是進程正常結束或其他原因造成中斷。四種事件會導致進程終止:</p>
<ol>
<li>正常退出(自願)</li>
<li>出錯退出(自願)</li>
<li>嚴重錯誤(非自願)</li>
<li>被其他進程殺死(非自願)</li>
</ol>
</li>
</ul>
<h3><span id="進程的實現">進程的實現</span></h3><p>為實現進程模型，操作系統維護著一張表格 (數組 or 鏈表結構)，即<strong>進程表 (process table)</strong>。每個進程占用一個進程表項。該表象包含了進程狀態的重要信息，包括寄存器、程序計數器、堆棧指針和優先級等以及其他在進程由運行態轉換到就緒態或阻塞態時必須保存的信息，從而保證甘進程隨後能再次啓動，就像從未被中斷過一樣。</p>
<p>了解進程表後，就可以對在 CPU 上如何維持多個順序進程的錯覺進行更多的闡述。與每一 I/O 淚關聯的是一個稱作<strong>中斷向量 (interrupt vector)</strong>的位置。它包含中斷服務程序的入口地址。假設當一個磁盤中斷發生時，某用戶進程正在運行，則中斷硬件將程序計數器、程序狀態字和寄存器等壓入堆棧，計算機隨即跳轉到中段向量所指示的地址。</p>
<p>以下為中斷發生後操作系統最底層的工作順序:</p>
<ol>
<li><p>硬件壓入堆棧程序計數器等</p>
</li>
<li><p>硬件從中斷向量裝入新的程序技術器</p>
</li>
<li><p>彙編語言過程保存寄存器值</p>
</li>
<li><p>彙編語言過程設置新的堆棧</p>
</li>
<li><p>C中斷服務例程運行</p>
</li>
<li><p>調度程序決定下一個將運行的進程</p>
</li>
<li><p>C過程返回至彙編代碼</p>
</li>
<li><p>彙編語言過程開始運行新的當前進程</p>
</li>
</ol>
<h2><span id="線程">線程</span></h2><p>需要線程的主要原因:</p>
<ol>
<li>在許多應用中同時發生著多種活動。其種某些活動隨著時間的推移會被阻塞。通過將這些應用程序分解成可以準並行的多個線程，程序設計會更加簡單。</li>
<li>由于線程比進程更輕量級，所以他們比進程更快更容易創建，也更容易撤銷。</li>
<li>性能問題。多個線程都是 CPU 密集型的，那麽並不能獲得性能上的增強，但是如果存在這大量的計算和大量的 I/O 處裏，擁有多個線程允許這些活動彼此重疊進行，從而加快應用程序執行的速度。</li>
</ol>
<h3><span id="進程-vs-線程">進程 v.s. 線程</span></h3><p>線程是進程劃分成更小的運行單位，一個進程在其執行的過程中可以産生多個線程。線程和進程最大的不同在于基本上各進程是獨立的，而各線程則不一定，因為同一進程中的線程有可能會互相影響 (沒有保護)，多個線程可以共享公共內存，對彼此進行讀寫。進程執行開銷大，但利于資源的管理與保護，線程則相反。</p>
<h3><span id="多線程">多線程</span></h3><p>線程給進程模型中增加了一項內容，即在同一進程環境中，允許彼此之間有較大獨立性的多個線程執行。在同一進程中並行運行多個線程 (多個線程共享同一各地址空間和資源)，是對在同一計算機上並行運行多個進程 (多個進程共享物理內存、磁盤等資源)的模擬。多線程是用來描述在同一各進程中允許多個線程的情形 (允許線程切換在納秒級完成)。</p>
<h3><span id="線程狀態">線程狀態</span></h3><p><img src="https://i.imgur.com/iVmZzxs.png" alt="Thread State"></p>
<ul>
<li><strong>創建 (New)</strong>: 創建線程</li>
<li><strong>就緒 (Ready)</strong>: 可以被調度執行</li>
<li><strong>運行 (Running)</strong>: 擁有 CPU 並且是活躍的</li>
<li><strong>阻塞 (Blocking)</strong>: 等待某個釋放它的事件</li>
<li><strong>終止 (Dead)</strong>: 不可被調度執行</li>
</ul>
<h2><span id="進程間通信-inter-process-communication-ipc">進程間通信 (Inter Process Communication, IPC)</span></h2><p>進程間通信主要需要解決三個問題:</p>
<ol>
<li>一個進程如何把信息傳遞給另一個</li>
<li>確保兩個或更多的進程在關鍵活動中不會出現交叉</li>
<li>保證線程的正確順序</li>
</ol>
<h3><span id="競爭條件">競爭條件</span></h3><p>兩個或多個進程讀寫某些共享數據，而最後的結果取決于進程運行的時序，稱為<strong>競爭條件 (race condition)</strong>。比如一機器有許多槽位並且進程 A 與進程 B 開始如下操作:</p>
<ol>
<li>進程 A 先運行，發現槽位3為空並且進行標記，此時發生時鍾中斷， CPU 認為 A 已經運行足夠長時間，決定切換到進程 B 運行。</li>
<li>進程 B 運行，同樣發現槽位3為空並且進行標記。</li>
<li>進程 B 繼續運行，將文件存儲到槽位3。</li>
<li>進程 A 接著從上次中斷的地方開始運行，同樣將文件存儲到槽位3，覆蓋掉 B 的文件。</li>
<li>此結果將會造成 B 永遠得不到結果。</li>
</ol>
<h3><span id="臨界區">臨界區</span></h3><p>對共享內存進行訪問的程序片段稱為<strong>臨界區域 (critical region)</strong> 或<strong>臨界區 (critical section)</strong> 。要避免競爭條件，需要滿足以下四個條件:</p>
<ol>
<li>任何兩個進程不能同時處于其臨界區</li>
<li>不對 CPU 的速度和數量作任何假設</li>
<li>臨界區外運行的進程不得阻塞其他進程</li>
<li>不得使進程無限期等待進入臨界區</li>
</ol>
<h3><span id="忙等待的互斥">忙等待的互斥</span></h3><p>要避免造成上述錯誤，要找出某種途徑來阻止多個進程同時寫共享數據，即確保當一個進程在使用一個共享變量或文件時，其他進程不能做同樣的操作 or 不會進入臨界區，該動作稱為<strong>互斥 (mutual exclusion)</strong>。要實現互斥有以下幾種方案:</p>
<ol>
<li><p><strong>屏蔽中斷</strong>: 每個進程在進入臨界區後立即屏蔽所有中斷，並在要離開之前再打開中斷。屏蔽中斷後，時鍾中斷也會被屏蔽。CPU 只有發生時鍾中斷或其他中斷時才會進行進程切換，代表在屏蔽中斷之後 CPU 將不會被切換到其他進程。這樣一但某個進程屏蔽中斷之後，它就可以檢查和修改共享內存，而不必擔心其他進程介入。屏蔽中斷對于操作系統本身而言是一項很有用的技術，但對于用戶進程不是一種合適的互斥機制。</p>
</li>
<li><p><strong>鎖變量</strong>: 設0表示臨界區內沒有進程，1表示已經有某個進程進入臨界區。一個共享 (鎖) 變量，其初始值為0，當一個進程想進入其臨界區時，它首先測試這把鎖，如果鎖值為0，則該進程將其設置為1並進入臨界區。若這把鎖的值已經為1，則該進程將等待直到其值變為0。</p>
</li>
<li><p><strong>嚴格輪換法</strong>: 該方案要求兩個進程嚴格地輪流進入臨界區，任何一各進程都不可能在一輪中執行兩次。設整型變量 turn 初始值為0，用于記錄輪到哪個進程進入臨界區，並檢查或更新共享內存。開始時，進程0檢查 turn, 發現值為0，于是進入臨界區。進程1也發現其值為0，所以在一個等待循環中不停地測試 turn, 看其值何時變為1。</p>
</li>
</ol>
<blockquote>
<p>連續測試一個變量到某個值出現為止，稱為<strong>忙等待 (busy waiting)</strong>。由于這種方式浪費 CPU 時間，所以通常應該避免。只有在有理由認為等待時間是非常短的情形下，才使用忙等待。用于忙等待的鎖稱為<strong>自旋鎖 (spin lock)</strong>，也是互斥鎖的一種表現形式</p>
</blockquote>
<p>   盡管該算法避免了所有的競爭條件，但由于違反了條件3 – 臨界區外運行的進程不得阻塞其他進程，所以不能作為一個很好的備選方案。</p>
<ol start="4">
<li><p><strong>Peterson 解法</strong>: 在使用共享變量 (即進入臨界區) 之前，各疙進程使用其進程號0或1作為參數來調用 enter_region。該調用在需要時將使進程等待。直到能安全地進入臨界區。在完成對共享變量的操作之後，進城將調用 leave_region，表示操作以完成，若其他的進程希望進入臨界區，現在就可以進入。</p>
</li>
<li><p><strong>TSL 指令</strong>: 該方案需要硬件支持。某些計算機中，特別是那些設計為多處裏器的計算機，都有一條指令: TSL RX, LOCK，稱為測試並加鎖 (test and set lock)，它將一個內存字 lock 讀到寄存器 RX 中，然後再該內存地址上存一個非零值。讀字和寫字操作保證是不可分割的，即該指令結束之前其他處裏器均不允許訪問該內存字。執行 TSL 指令的 CPU 將鎖住內存總線，以禁止其他 CPU 在本指令結束之前訪問內存。與屏蔽中斷不同的是，屏蔽中斷無法阻止處裏器2在處裏器1的讀操作與寫操作之間訪問內存字，鎖住存儲總線則可以。</p>
</li>
</ol>
<h3><span id="睡眠-sleep-與喚醒-wakeup">睡眠 (sleep) 與喚醒 (wakeup)</span></h3><p>Peterson 解法與 TSL 解法都是正確的，但他們都有<strong>忙等待</strong>的缺點，他們本質上是這樣的，當一個進程想進入臨界區時，先檢查是否允許進入，若不允許，則該進程將原地等待，直到允許為止。這種方法不僅浪費 CPU 時間，而且還可能引起<strong>優先級反轉問題 (priority inversion problem)</strong>。</p>
<blockquote>
<p>優先級反轉問題 (priority inversion problem): 考慮一台計算機有兩個進程，A進程優先級較高，B較低。調度規則規定，只要A處于就緒態它就可以運行。在某一時刻，B處于臨界區中，此時A變到就緒態，準備運行。現在A開始忙等待，但由于當A就序時B不會被調度，也就無法離開臨界區，所以A將永遠忙等待下去。</p>
</blockquote>
<p>接下來則引入 <strong>sleep</strong> 和 <strong>wakeup</strong>，他們在進程無法進入臨界區時將其阻塞，而非忙等待。 </p>
<p><strong>生産者 - 消費者 (producer-consumer) 問題</strong><br>兩個進程共享一個公共的固定大小的緩衝區，其中一個是生産者，將信息放入緩衝區，另一個是消費者，從緩衝區中取出信息。當緩衝區已滿，而此時生産者還想向其中放入一個新的數據項的情況。其解決辦法是讓生産者睡眠 (sleep)，待消費者從緩衝區中取出一個或多個數據項時再喚醒它，反之亦然。</p>
<h3><span id="信號量-semaphore">信號量 (semaphore)</span></h3><p>信號量是一個計數器，有相較于互斥量更多的取值空間。不單單可以實現線程間的互斥，更可以用于較為複雜的<strong>進程同步 (synchronization，亦可稱為同步鎖的一種)</strong>。這種通信方式主要用于解決與同步相關的問題並避免競爭條件。</p>
<h3><span id="互斥量-or-互斥鎖-mutex">互斥量 or 互斥鎖 (mutex)</span></h3><p>信號量的簡化版本，可以說是信號量再僅取值 0/1 時的特例，僅適用于管理共享資源或一小段代碼。互斥量是一個可以處于兩態之一的變量: 解鎖或加鎖 (<strong>二元鎖</strong>機制)。當一個線程 (或進程) 需要訪問臨界區時，調用 mutex_lock。如果該互斥量當前是解鎖的 (即臨界區可用)，此調用成功，調用線程可以自由進入該臨界區。如果該互斥量已經加鎖，調用線程將被阻塞，直到再臨界區中的線程完成並調用 mutex_unlock。如果多個線程被阻塞再該互斥量上，將隨機選擇一個線程並允許它獲得鎖。采用互斥對象機制，只有擁有互斥對象的線程才有訪問公共資源的權限。因為互斥對象只有一個，所以可以保證公共資源不會被多個線程同時訪問</p>
<h2><span id="調度">調度</span></h2><p>對調度的定義如下:</p>
<blockquote>
<p>當計算機系統是多道程序設計系統時，通常就會有多個進程或線程同時競爭 CPU。指要有兩個或更多的進程處于就緒狀態，這種情形就會發生。如果只有一個 CPU 可用，那麽就必須選擇下一個要運行的進程。再操作系統中，完成選擇工作的這一部份稱為<strong>調度程序 (scheduler)</strong>，該程序使用的算法稱為<strong>調度算法 (scheduling algorithm)</strong>。</p>
</blockquote>
<p>盡管有些不同，但許多適用于進程調度的處裏方法同樣也是用于線程調度。</p>
<h3><span id="何時調度">何時調度</span></h3><p>需要調度處裏的各種情形:</p>
<ol>
<li><p>在創建一個新進程之後，需要決定是運行父進程還是子進程</p>
</li>
<li><p>在一個進程退出時必須做出調度決策</p>
</li>
<li><p>當一個進程阻塞在 I/O 和信號量上或由于其它原因阻塞時，必須選擇另一個進程運行</p>
</li>
<li><p>在一個 I/O 中斷發生時，必須做出調度決策</p>
</li>
</ol>
<p>如果硬件時中提供周期性中斷，可以在每個或 n 個時鍾中斷時做出調度決策。根據如何處裏時鍾中斷，可以把調度算法分為兩大類:</p>
<ul>
<li><p><strong>非搶占式</strong>: 挑選一個進程，然後讓進程運行直至被阻塞或釋放 CPU。即使該進程運行很久，它也不會被強迫挂起。這樣做的結果是，在時鍾中斷發生時不會進行調度。在處裏完時鍾中斷後，如果沒有更高優先級的進程等待，則被中斷的進程會繼續執行。</p>
</li>
<li><p><strong>搶占式</strong>: 挑選一個進程，並且讓該進程運行某個固定時段的最大值，如果該時段結束時，該進程仍在運行，他就被挂起，而調度程序挑選另一個進程運行。</p>
</li>
</ul>
<h3><span id="常見進程調度算法">常見進程調度算法</span></h3><ul>
<li><strong>先到先服務 (First Come First Served, FCFS)</strong>: 從就緒隊列中選擇一個最先進入該隊列的進程為其分配資源，使它立即執行並一直執行到完成或發生某事件而被阻塞，放棄占用 CPU 時再重新調度。</li>
<li><strong>最短作業優先 (Shortest Job First, SJF)</strong>: 從就緒隊列中選出一個估計運行時間最短的進程為其分配資源，使它立即執行並一直執行到完成或發生某事件而被阻塞，放棄占用 CPU 時再重新調度。</li>
<li><strong>最短剩余時間優先 (Shortest Remaining Time First, SRTS)</strong>: 調度程序總是選擇剩余運行時間最短的那個進程運行。</li>
<li><strong>時間片輪轉調度 (Round-Robin, RR)</strong>: 最古老，最簡單，最公平且使用最廣的算法，每個進程被分配一個時間段，稱作它的時間片，即該進程允許運行的時間。</li>
<li><strong>優先級調度 (Priority Based Scheduling)</strong>: 為每個流程分配優先級，首先執行具有最高優先級的進程。具有相同優先級的進程以 FCFS 的方式執行。可以根據內存要求，時間要求或任何其他資源要求來確定優先級。</li>
<li><strong>多級反饋隊列調度算法 (Multi-level Feedback Queue, MFQ)</strong>: 該算法既能使高優先級的作業得到響應又能使短作業 (進程) 迅速完成，因而他是目前被<strong>公認的一種較好的進程調度算法，UNIX 便是采用這種算法</strong>。</li>
<li><strong>最短進程優先 (Shortest Process First, SPF)</strong>: 優先運行最短的作業以達到響應時間最短，該算法雖然照顧了短進程卻忽略了長進程。</li>
<li><strong>彩票調度 (Lottery Scheduling)</strong>: 向進程提供各種系統資源 (如 CPU 時間) 的彩票 (可以給重要的進程額外的彩票)。一旦需要做出一項調度決策時，就隨機收出一張彩票，擁有該彩票的進程獲得該資源。</li>
<li><strong>公平共享調度 (Completely Fair Scheduling)</strong>: 在調度處裏之前考慮誰擁有該進程。在這種模式下，每個進程分配到 CPU 時間的一部份，而調度程序以一種強制的方式選擇進程。如果兩個用戶都得到 50% 的 CPU 時間保證，那麽無論一個用戶有多少進程存在，每個用戶都會得到應有的 CPU 份額。</li>
</ul>

            </div>
        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li><br>
                Tsung Han Tsai © 2018 - 2021 • All rights reserved
            </ul>
        </div>
    </div>
</body>

 	
</html>
