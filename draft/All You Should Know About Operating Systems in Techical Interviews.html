<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/me.jpg"/>
	<link rel="shortcut icon" href="/img/me.jpg">
	<script data-ad-client="ca-pub-3134773914228719" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	
			    <title>
    Jack's Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="java, computer science, programming" />
    <meta data-react-helmet="true" property="og:image" content="https://www.jacktsaitech.com/images/Cover Page.png">
    <meta data-react-helmet="true" property="og:type" content="website">
    <meta data-react-helmet="true" property="og:url" content="https://www.jacktsaitech.com">
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/highlight.js"></script>
	
<meta name="generator" content="Hexo 6.0.0"><link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_okaidia.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <!-- <header id="header">
    <a href="/" class="logo">JACK</a>
</header> -->
        <header id="post-header"></header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">Home</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            	<a href="#s1">Category</a>
	                    <ul class="submenu">
	                        <li>
	                        
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/tag/" title="Tag">
		                Tag
		            </a>
		        </li>
		        
		        <li>
		            <a href="/about/" title="About">
		                About
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
					<li class="translate-style">
						<a id="translateButtonObject" href="javascript:translatePage();">繁&#8644;简</a>
					</li>
                    
                    <li>
                        <a title="github" href="https://github.com/jack870131" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="linkedin" href="https://www.linkedin.com/in/tsung-han-jack-tsai-62696314b" target="_blank" rel="noopener">
                            <i class="icon fa fa-linkedin"></i>
                        </a>
                    </li>
                    
			</ul>
			<script type="text/javascript" src="/js/tw_cn.js"></script>
			<script type="text/javascript">
				var defaultEncoding = 2; //網站編寫字體是否繁體，1-繁體，2-簡體
				var translateDelay = 0; //延遲時間,若不在前, 要設定延遲翻譯時間, 如100表示100ms,默認為0
				var cookieDomain = "https://jack870131.github.io/"; //Cookie地址, 一定要設定, 通常為你的網址
				var translateButtonId = "translateLink"; //默認互換id
				translateInitilization();
			</script>
</nav>

        <div id="main" >
            <div class ="post_page_title_img"></div>
            <!-- Post -->
            <div class="typo">
                <h1><span id="all-you-should-know-about-operating-systems-in-technical-interviews">All You Should Know About Operating Systems in Technical Interviews</span></h1><p><img src="/images/%E6%96%B0%E6%96%87%E5%AD%97%E6%96%87%E4%BB%B6/Operating%20Systems.png" alt></p>
<h2><span id="introduction">Introduction</span></h2><h3><span id="what-is-operating-systems">What is operating systems?</span></h3><p>The definition of operating systems can be divided into three parts:</p>
<ol>
<li>An operating system provides an interface for users to interact with the computer hardware.</li>
<li>An operating system (OS) is a program managing hardware and software resources of the computer.</li>
<li>An operating system is structured by a kernel and some other basic components. In general, the kernel is a bridge between applications and hardware. It is responsible for managing stuff like process, internal memory, file, and network, which has the direct access to hardware and maintains stability and performance of the system.</li>
</ol>
<img src="/images/All%20You%20Should%20Know%20About%20Operating%20Systems%20in%20Techical%20Interviews/Operating%20Systems%201.png" style="zoom:67%;">

<h3><span id="how-do-users-access-computer-resources">How do users access computer resources?</span></h3><p>The computer operation can be divided into two modes:</p>
<ol>
<li><strong>User mode</strong>: The process under this level can only access the data that users provide.</li>
<li><strong>Kernel mode</strong>: The process under this level has complete access to computer hardware and can execute some special operations of the machine (e.g., I/O).</li>
</ol>
<p>The typical applications often run under the user mode. When there is a demand for service under kernel mode, a system call should be issued. It is a request that asking kernel process to execute functions such as device management, file management, process management, and memory management.</p>
<img src="/images/Operating%20Systems%202.png" style="zoom:67%;">

<h2><span id="processes-amp-threads">Processes &amp; Threads</span></h2><h3><span id="what-is-the-difference-between-processes-and-threads">What is the difference between processes and threads?</span></h3><p>In short, a process is an active program. It can generate multiple threads while executing. Processes are usually independent of each other, but threads are not necessarily. Processes will lead to more overhead but are also more convenient for the management, and threads are just the opposite.  </p>
<p>Take JVM process as an example, threads inside are sharing global variables such as heap space and method area (metaspace), but Program Counter Register, JVM stack and native method stack are private.</p>
<p><img src="/images/Operating%20Systems%203.png" alt></p>
<h3><span id="what-are-states-of-the-process">What are states of the process?</span></h3><p>There are 7 states of the process, which are:</p>
<ol>
<li><strong>New</strong>: The process is creating.</li>
<li><strong>Ready</strong>: The process is ready to run, i.e., it is waiting the resources (e.g., time slices) from processor.</li>
<li><strong>Run</strong>: The process is currently running in CPU. Only one process is allowed at a time.</li>
<li><strong>Wait (or Block)</strong>: The process is paused and waiting for the required resources to be available.</li>
<li><strong>Complete (or Terminated)</strong>: The process has finished executing. It might be interrupted by some reasons or normal exit. </li>
<li><strong>Suspended Ready</strong>: The process is suspended while the ready queue is full.</li>
<li><strong>Suspended Block</strong>: The process is suspended while the waiting queue is full.</li>
</ol>
<img src="/images/Operating%20Systems%204.png" style="zoom:67%;">

<h3><span id="what-is-context-switching-when-will-it-happen">What is context switching? When will it happen?</span></h3><p>Context switching means saving the running process state and loading the state of another process. This usually happens while a higher-priority process comes into the ready state or an interrupt occurs.</p>
<h3><span id="what-is-a-race-condition">What is a race condition?</span></h3><p>A race condition happens while more than one process are sharing the same code or resources. In this case, an unexpected result might occur as each process could access the shared variables at any time.</p>
<h3><span id="how-do-processes-communicate-with-each-other">How do processes communicate with each other?</span></h3><p>There are six ways of inter-process communications (IPC):</p>
<ol>
<li><strong>Pipe</strong>: It enables the output of a process become the input of another process that has a <strong>common origin</strong>, i.e., the same process. The data flow by using pipe is one direction only (e.g., command “|” in Linux).</li>
<li><strong>Names pipe</strong>: This allows communication of processes from different origin. It follows first in first out (FIFO) rules.</li>
<li><strong>Message queueing</strong>: Both types of pipes are inefficient as the process that sends data into the buffer needs to wait until another process retrieves it. Message queueing is able to solve this problem, which producers do not need to wait for consumers retrieving data.</li>
<li>*<em>Shared memory: *</em> There is also a disadvantage of message queueing, which is time-consuming while the size of sending data is too large. Hence an idea of shared memory came up. It allows multiple processes access the same area of memory. This is the most efficient way as each process can see the update of data immediately.</li>
<li><strong>Semaphore</strong>: The biggest issue of shared memory is that multiple processes will compete for resources. Semaphore is a program counter used in process synchronization to control the number of processes accessing shared memory and avoid race condition. It represents how much resources are available in shared memory.</li>
<li><strong>Socket</strong>: All communication methods mentioned above are based on only one device. Socket is an interface which allows communicating between multiple device remotely. It is mainly used in the client/server communication.</li>
</ol>
<h3><span id="how-do-threads-synchronize-with-each-other">How do threads synchronize with each other?</span></h3><p>The purpose of thread synchronization is similar to inter-process communication, which avoid competing shared resources between concurrent threads. There are three common ways of thread synchronization:</p>
<ol>
<li><strong>Mutex</strong>: It is a mechanism of mutual exclusion. Mutex only allows one thread accesses the shared resources at a time (e.g., <code>synchronized</code> in Java).</li>
<li><strong>Semaphore</strong>: It is quite similar to mutex, but its value could be larger than 1 and allows multiple threads enter shared resources at a time.</li>
<li><strong>Event</strong>: It remains thread synchronization by notification (wait/notify).</li>
</ol>
<h3><span id="how-does-the-cpu-schedule-processes">How does the CPU schedule processes?</span></h3><p>There are several CPU scheduling algorithms in order to achieve maximum CPU utilization:</p>
<ol>
<li><strong>First Come First Serve (FCFS)</strong>: Allocate resources to a process within the ready queue that requests the CPU first. It is a non-preemptive algorithm (the scheduled process will run until completed or blocked).</li>
<li><strong>Shortest Job First (SJF)</strong>:  Allocate resources to a process within the ready queue that has shortest execution time. It is a non-preemptive algorithm. There is also a longest job first (LJF) scheduling algorithm.</li>
<li><strong>Shortest Remaining Time First (SRTF)</strong>: Allocate resources to a process within the ready queue that has shortest remaining execution time. It is a preemptive algorithm (the scheduled process can be preempted while a higher priority process enters). There is also a longest remaining time first (LRTF) scheduling algorithm.</li>
<li><strong>Round Robin</strong>: Each process is allocated with a given time called time slice and executes until the time runs out.</li>
<li>*<em>Priority Based *</em>: Each process is assigned with a given priority. The higher the priority, the  earlier to be selected.</li>
<li><strong>Multilevel Queue</strong>: Processes are allocated in different queues in terms of their priority. Processes in lower level queues are allowed to execute until the processes in higher level queues are completed.</li>
<li><strong>Multilevel Queue Feedback</strong>: This is the scheduling algorithm used in UNIX system, which allows processes moving between each level queue. The process will be moved to the lower level queue if it costs too much execution time.</li>
</ol>
<h2><span id="memory-management">Memory Management</span></h2><h3><span id="how-does-memory-model-designed-in-operating-systems">How does memory model designed in operating systems?</span></h3><p>There are two types of memory in operating systems:</p>
<ol>
<li><strong>Primary memory (internal memory)</strong>: CPU registers, cache memory and main memory, which are directly accessible by the processor.</li>
<li><strong>Secondary memory (external memory)</strong>:  different  types of disk (magnetic, optical), which are some storage devices that can accessed by the processor through I/O.</li>
</ol>
<p><img src="/images/All%20You%20Should%20Know%20About%20Operating%20Systems%20in%20Techical%20Interviews/Operating%20Systems%205-1603431301177.png" alt></p>
<h3><span id="how-does-memory-management-work-in-operating-systems">How does memory management work in operating systems?</span></h3><p>The memory management of operating systems is responsible for allocating memory to processes, including converting logical addresses into physical addresses or swapping processes between internal and external memory.</p>
<h3><span id="what-are-virtual-address-and-physical-address">What are virtual address and physical address?</span></h3><p>Take a common example, the pointer concept we see in some programming languages stores the virtual address of memory, which is decided by operating systems. The physical address is the address in physical memory, i.e., memory address registers.</p>
<p>Modern processors use virtual addressing technique to translate a virtual address into a physical address via MMU (memory management unit). The process of virtual addressing is shown in the image below:</p>
<p><img src="/images/All%20You%20Should%20Know%20About%20Operating%20Systems%20in%20Techical%20Interviews/Operating%20Systems%206.png" alt></p>
<h3><span id="how-do-operating-systems-allocate-memory">How do operating systems allocate memory?</span></h3><p>There are four types of common memory allocation techniques:</p>
<ol>
<li><strong>Partitioned allocation</strong>: Divide memory by blocks and each of them contains one process. Space would be wasted if the process only needs a small memory to run. This is contiguous allocation as those blocks are consecutive in memory.</li>
<li><strong>Paged memory management</strong>: Divide memory by page frames, which are units smaller than blocks. This increases the use of memory and reduces internal fragmentation. It is non-contiguous allocation as page frames are allowed to be separated. Paged tables are used to mapping virtual addresses to physical addresses.</li>
<li><strong>Segmented memory management</strong>: Divide memory by segments, which are logical groups of the data or code. It is non-contiguous allocation as segments are allowed to be separated. Segment tables are used to mapping virtual addresses to physical addresses.</li>
<li><strong>Segmentation with paging</strong>: Combines the advantages of paged and segmented memory management. It divides memory by several segments, then separates each segment into several page frames.</li>
</ol>
<h3><span id="what-is-tlb-translation-lookaside-buffer">What is TLB (Translation Lookaside Buffer)?</span></h3><p>In paged memory management, there are two issues need to be handled:</p>
<ol>
<li>The virtual-to-physical mapping should be fast.</li>
<li>The page table will become large while the virtual address space is large.</li>
</ol>
<p>TLB could be applied to speed up the transition between virtual and physical memory. It could be regarded as a cache, which stores a part of data inside a page table. With this cache, we only need to access the main memory once instead of twice while executing I/O.</p>
<p>The process of translating a virtual address into a physical address is:</p>
<ol>
<li>Search for the page number inside TLB.</li>
<li>If the given page is found, read the corresponding physical address from TLB.</li>
<li>If the given page cannot be found, read the corresponding physical address inside the page table and store it into TLB.</li>
<li>Eliminate a page inside TLB by certain strategies while it is full.</li>
</ol>
<h3><span id="what-is-a-multilevel-page-table">What is a multilevel page table?</span></h3><p>Besides speeding up mapping, we can use a multilevel page table to handle the issue caused by the large virtual address space. It avoids always placing all the page tables in main memory, which could save up more space.</p>
<h3><span id="what-is-virtual-memory">What is virtual memory?</span></h3><p>This is common while the memory cost by a software exceeds the memory of the computer itself. The reason why this can be implemented is because of the virtual memory. It divides a program into several pieces and allows them to be temporarily stored on the external memory (disk) before the program needs it. By doing this, the program will regard itself to own a piece of continuous space.</p>
<h3><span id="how-to-implement-virtual-memory">How to implement virtual memory?</span></h3><p>There are two common types of virtual memory implementation:</p>
<ol>
<li><strong>Demand paging</strong>: It is based on the paging technique and has the page replacement function. If we cannot find the  required page before a process starts, the operating system will search it in the secondary memory and swap the page found into the main memory depending on the given page replacement algorithm.</li>
<li><strong>Demand segmentation</strong>: It is a technique similar to demand paging. The only difference between them is that demand segmentation swap segments instead of pages into the main memory depending on the given segment replacement algorithm.</li>
</ol>
<h3><span id="what-is-page-replacement-algorithm">What is page replacement algorithm?</span></h3><p>Page fault happens while a required page is not in the main memory. And we need page replacement algorithms to swap the page from the secondary memory into the main memory. Some common types of page replacement algorithms are listed below:</p>
<ol>
<li><strong>Optimal page replacement</strong>: Replace the page that is no longer used or will not be used for the longest time. This will ensure the lowest possibility of page fault. However, OPT replacement cannot be achieved so far as people cannot predict which page will not be used again in the future.</li>
<li><strong>FIFO (First-In-First-Out) page replacement</strong>: Eliminate the page that stays in the main memory for the longest time.</li>
<li><strong>LRU (Least Recently Used) page replacement</strong>: Eliminate the page with the longest elapsed time since it was last accessed.</li>
<li><strong>LFU (Least Frequently Used) page replacement</strong>: Eliminate the least used page in a period of time.</li>
</ol>
<h3><span id="what-is-a-deadlock-in-operating-systems">What is a deadlock in operating systems?</span></h3><p>Deadlock is a situation when more than two processes are waiting for the resource holding by each other, but no one is going to terminate first.</p>
<p><img src="/images/All%20You%20Should%20Know%20About%20Operating%20Systems%20in%20Techical%20Interviews/Operating%20systems%207.png" alt></p>
<h2><span id="references">References</span></h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.amazon.com/Modern-Operating-Systems-Andrew-Tanenbaum/dp/013359162X">Modern Operating Systems: Tanenbaum, Andrew, Bos, Herbert</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide">Snailclimb/<em>JavaGuide</em> - GitHub</a></li>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/operating-system-introduction-operating-system-set-1/">Introduction of Operating System</a></li>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/operating-system-microkernel/">Microkernel in Operating System</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Kernel_(operating_system)">Kernel (operating system) - Wikipedia</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Operating_system">Operating system - Wikipedia</a></li>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/introduction-of-process-management/">Introduction of Process Management - GeeksforGeeks</a></li>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/introduction-of-process-synchronization/">Introduction of Process Synchronization - GeeksforGeeks</a></li>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/methods-in-interprocess-communication/">Methods in Interprocess Communication - GeeksforGeeks</a></li>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/">CPU Scheduling in Operating Systems - GeeksforGeeks</a></li>
<li><a target="_blank" rel="noopener" href="https://www.tutorialspoint.com/operating_system/os_process_scheduling_algorithms.htm">Operating System Scheduling algorithms - Tutorialspoint</a></li>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/paging-in-operating-system/">Paging in Operating System - GeeksforGeeks</a></li>
<li><a target="_blank" rel="noopener" href="https://www.javatpoint.com/os-demand-paging">OS Demand Paging - javatpoint</a></li>
<li><a target="_blank" rel="noopener" href="https://www.quora.com/What-is-demand-segmentation">What is demand segmentation? - Quora</a></li>
</ol>

            </div>
        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li><br>
                Tsung Han Tsai © 2018 - 2021 • All rights reserved
            </ul>
        </div>
    </div>
</body>

 	
</html>
