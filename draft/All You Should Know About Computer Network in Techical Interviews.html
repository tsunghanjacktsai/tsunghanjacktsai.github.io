<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/me.jpg"/>
	<link rel="shortcut icon" href="/img/me.jpg">
	<script data-ad-client="ca-pub-3134773914228719" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	
			    <title>
    Jack's Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="java, computer science, programming" />
    <meta data-react-helmet="true" property="og:image" content="https://www.jacktsaitech.com/images/Cover Page.png">
    <meta data-react-helmet="true" property="og:type" content="website">
    <meta data-react-helmet="true" property="og:url" content="https://www.jacktsaitech.com">
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/highlight.js"></script>
	
<meta name="generator" content="Hexo 6.0.0"><link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_okaidia.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <!-- <header id="header">
    <a href="/" class="logo">JACK</a>
</header> -->
        <header id="post-header"></header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">Home</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            	<a href="#s1">Category</a>
	                    <ul class="submenu">
	                        <li>
	                        
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/tag/" title="Tag">
		                Tag
		            </a>
		        </li>
		        
		        <li>
		            <a href="/about/" title="About">
		                About
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
					<li class="translate-style">
						<a id="translateButtonObject" href="javascript:translatePage();">繁&#8644;简</a>
					</li>
                    
                    <li>
                        <a title="github" href="https://github.com/jack870131" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="linkedin" href="https://www.linkedin.com/in/tsung-han-jack-tsai-62696314b" target="_blank" rel="noopener">
                            <i class="icon fa fa-linkedin"></i>
                        </a>
                    </li>
                    
			</ul>
			<script type="text/javascript" src="/js/tw_cn.js"></script>
			<script type="text/javascript">
				var defaultEncoding = 2; //網站編寫字體是否繁體，1-繁體，2-簡體
				var translateDelay = 0; //延遲時間,若不在前, 要設定延遲翻譯時間, 如100表示100ms,默認為0
				var cookieDomain = "https://jack870131.github.io/"; //Cookie地址, 一定要設定, 通常為你的網址
				var translateButtonId = "translateLink"; //默認互換id
				translateInitilization();
			</script>
</nav>

        <div id="main" >
            <div class ="post_page_title_img"></div>
            <!-- Post -->
            <div class="typo">
                <h1><span id="computer-network">Computer Network</span></h1><h2><span id="introduction">Introduction</span></h2><h2><span id="1-what-does-the-architecture-of-computer-network">1. What does the architecture of computer network?</span></h2><p>In general, computer network concepts often be divided into 5 main layers. This is the combination of OSI (Open System Interconnection) model and TCP/IP model, which have 7 layers and 4 layers respectively.</p>
<p><img src="/images/Computer%20Network/image-20201116152624596.png" alt></p>
<h2><span id="2-what-are-the-functions-of-each-layer">2. What are the functions of each layer?</span></h2><p>The following introduction will be based on the OSI network model:</p>
<ol>
<li><strong>Application</strong>: The task of application layer is to specify the communication protocols or interfaces between application processes run by host. There are some general protocols in application layer, e.g., HTTP (Hyper Text Transfer Protocol), DNS (Domain Name System), and SMTP.</li>
<li><strong>Presentation</strong>: This layer is mainly responsible for translating data from application layer into the required format (e.g., ASCII). Some work such as data encryption/decryption and compression are done here.</li>
<li><strong>Session</strong>: This layer is responsible to establish and maintain connection or session between two processes. It also allows processes adding checkpoints for synchronization.</li>
<li><strong>Transport</strong>: It provides the end-to-end data (segments) transfer service between applications over networks. The best-known protocols of transport layer are TCP (Transmission Control Protocol) and UDP (User Datagram Protocol).</li>
<li><strong>Network</strong>: The main functions of network layer is packet (data chunks) routing. To be specific, network layer choose the suitable routes for transmission and sends and receives IP (Internet Protocol) packets from other networks.</li>
<li><strong>Data link</strong>: This layer encapsulates IP packets from network layer into frames and send them over link nodes. Frame transmission depends on the MAC (Message Access Control) address. Receiver’s MAC address could be retrieved by sending ARP (Address Resolution Protocol) requests to see if any node has the required IP address.</li>
<li><strong>Physical</strong>: It is responsible for bit transmission between nodes, which is the physical connection (over physical data link) and eliminates the difference between devices as much as possible.</li>
</ol>
<h2><span id="3-what-is-tcp-amp-udp-in-the-transport-layer-what-are-their-differences">3. What is TCP &amp; UDP in the transport layer? What are their differences?</span></h2><p><strong>TCP (Transmission Control Protocol)</strong> is a connection-oriented service, which means it builds connection before transferring data and closes connection after the transmission. </p>
<p>The reliability of TCP reflects on establishing connection by a three-way handshake, and some mechanisms like error detection, flow control, congestion control, and retransmission. Those features will cost a lot of overhead and occupy the resources of processors. </p>
<p>TCP is often used in the file transmission, sending and receiving of mail, and remote login.</p>
<p><strong>UDP (User Datagram Protocol)</strong> does not need to build connection before the data transmission, which means that the remote host is not required to acknowledge after receiving UDP segments.</p>
<p>Although UDP cannot provide the reliable transmission, it is the most effective service under certain situations (instant messaging in general), e.g., real-time audio and video streaming.</p>
<p><img src="/images/Computer%20Network/image-20201119210643622.png" alt></p>
<h2><span id="4-how-does-tcp-build-and-terminate-connection">4. How does TCP build and terminate connection?</span></h2><p>We’ll first look at how TCP build connection in Client/Server model, which is generally called a three-way handshake:</p>
<ol>
<li>Client: It sends a SYN segment, which requests the server to synchronize its sequence number with the client’s sequence number.</li>
<li>Server: After receiving the packet from the client, the server will return SYN and ACK segments, which informs the client side that the packet had been received and asks it to provide the expected sequence number for the acknowledgment.</li>
<li>Client: It sends back a packet with an ACK segment, which informs the server that the returned packet had been correctly received.</li>
</ol>
<p><img src="/images/Computer%20Network/image-20201118141723333.png" alt></p>
<p>The SYN segment confirms that the route from sender to receiver has no problem, but the route from receiver to sender should be confirmed by ACK segment.</p>
<p>Next, we’re going to discuss how TCP terminates the connection in Client/Server model, which is a four-way handshake process:</p>
<ol>
<li>Client: After deciding to close the connection, the client will send a FIN segment to the server. Then the client will enter the FIN_WAIT_1 state waiting for the acknowledgment from the server.</li>
<li>Server: It sends back an ACK segment once the FIN segment from the client is received.</li>
<li>Client: It enters the FIN_WAIT_2 state after receiving the ACK segment from the server, which is waiting for a FIN segment sent from the other side.</li>
<li>Server: It also closes the connection with the client and sends a FIN segment after it sent the ACK segment.</li>
<li>Client: Once the ACK segment from the server is received, the client sends back the final ACK segment for acknowledgment. After, the client will enter the TIME_WAIT state, which the client formally closes after a while in case the final ACK segment is not received by the other side.</li>
</ol>
<p><img src="/images/Computer%20Network/image-20201118144024765.png" alt></p>
<h2><span id="5-what-is-arq-automatic-repeat-request">5. What is ARQ (Automatic Repeat Request)?</span></h2><p>ARQ is an error-control method for data transmission in transport layer and data link layer. Acknowledgments and timeouts are used to ensure reliable data transmission. If the receiver doesn’t get the acknowledgment within a given time, it will resend the packet until  the acknowledgment has been returned or exceeding the pre-defined times of retransmission.</p>
<p>There are two types of ARQ, including:</p>
<ul>
<li><p><strong>Stop-and-wait ARQ</strong>: The basic idea of Stop-and-wait ARQ is the sender will stop data transmission after each time sending a packet. The transmission will be regarded as a failure if getting no acknowledgment from the receiver after a given time. This means the data should be retransmitted until receiving the acknowledgment. If the receiver receives a duplicated packet, it should abandon this packet and send back an acknowledgment at the same time.</p>
</li>
<li><p><strong>Go-Back-N ARQ</strong>: The sender maintains a sliding window, which packets within this window can be sent continuously and there is no need to wait for acknowledgments. The receiver generally receives only in-order packets and sends back cumulative ACK after the last packet arrived.</p>
</li>
</ul>
<h2><span id="6-how-does-tcp-achieve-flow-control">6. How does TCP achieve flow control?</span></h2><p>The purpose of flow control is to control the speed of packet sending, which ensures the receiver can receive in time.</p>
<p>TCP can achieve flow control by sliding windows. The sliding window size at the sender side can be controlled by ACK segment returned by the receiver, which can also affect the sending speed.</p>
<h2><span id="7-how-does-tcp-achieve-congestion-control">7. How does TCP achieve congestion control?</span></h2><p>Network congestion happens when the requests for a network resource exceeds the amount of data it can handle.</p>
<p>Congestion control is to prevent excessive data from injected into the network so that the network links or nodes will not be overloaded.</p>
<p>TCP congestion control adopts various strategies, which are:</p>
<ol>
<li><strong>Slow start</strong>: Rather than ingesting a large amount of data into the network, TCP detects the resource allowance by first sending a small piece of data and gradually increase the congestion window (cwnd) size exponentially after each RTT (Round Trip Time).</li>
<li><strong>Congestion avoidance</strong>: After the congestion window (cwnd) size reaching the threshold, it starts increasing additively to avoid network congestion.</li>
<li><strong>Congestion detection</strong>: This happens when congestion occurs, the congestion window size will multiplicatively decrease. The congestion is assumed to happen when the packet retransmission is needed.</li>
<li><strong>Fast retransmit and recovery (FRR)</strong>: It is a congestion control algorithm that could fast recover lost packets. Without FRR, TCP will pause the transmission by a timer. During the pause, no new packets will be transmitted. With FRR, if the receiver receives a segment, it will return a duplicate ACK segment immediately. The sender will assume the segment lost after receiving three duplicate ACK segments. FRR reduces the delay of retransmission.</li>
</ol>
<h2><span id="references">References</span></h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/layers-osi-model">Layers of OSI Model</a></li>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/tcp-ip-model/?ref=lbp">TCP/IP Model</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">Transmission Control Protocol - Wikipedia</a></li>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/computer-network-tcp-connection-establishment/">TCP Connection Establishment</a></li>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/tcp-connection-termination/">TCP Connection Termination</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Stop-and-wait_ARQ">Stop-and-wait ARQ</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Go-Back-N_ARQ">Go-Back-N ARQ</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E19455-01/806-0916/6ja85398n/index.html">How the TCP/IP Protocols Handle Data Communications</a></li>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/difference-between-stop-and-wait-gobackn-and-selective-repeat/">Difference between Stop and Wait, GoBackN and Selective Repeat</a></li>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/tcp-congestion-control/">TCP congestion control</a></li>
</ol>

            </div>
        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li><br>
                Tsung Han Tsai © 2018 - 2021 • All rights reserved
            </ul>
        </div>
    </div>
</body>

 	
</html>
